使用方法：

用 stream() 函数传入列表，然后像java的Stream类一样操作。



# region 流式计算

class ListStream:
    def __init__(self, my_list=[]):
        self.list = list(my_list)

    def filter(self, func):
        self.list = list(filter(func, self.list))
        return self

    def map(self, func):
        self.list = list(map(func, self.list))
        return self

    def forEach(self, func):
        list(map(func, self.list))
        return self

    def print(self):
        self.forEach(lambda item: print(item))
        return self

    def collect(self):
        return self.list

class DictStream(ListStream):
    def __init__(self, my_dict={}):
        self.list = self.dict_to_list(my_dict)

    def collect(self, is_to_dict = True):
        if is_to_dict:
            return self.list_to_dict(self.list)
        else:
            return self.list

    def dict_to_list(self, old_dict):
        new_list = []
        for i in old_dict.keys():
            temp_dict = {}
            temp_dict["key"] = i
            temp_dict["value"] = old_dict[i]
            new_list.append(temp_dict)
        return new_list

    def list_to_dict(self, old_list):
        new_dict = {}
        for i in old_list:
            new_dict[i["key"]] = i["value"]
        return new_dict

def stream(iteration):
    def list_处理():
        return ListStream(iteration)

    def dict_处理():
        return DictStream(iteration)

    def default():
        raise Exception("stream化失败,参数类型未支持")

    switch = {
        "<class 'list'>": list_处理,
        "<class 'tuple'>": list_处理,
        "<class 'str'>": list_处理,
        "<class 'dict'>": dict_处理
    }
    return switch.get(repr(type(iteration)), default)()

# endregion 流式计算

if __name__ == '__main__':
    # list
    print()
    my_list = [1, 2, 3, 4, 5, 6]
    print(my_list)

    my_list_1 = list(map(lambda x: x ** 2, filter(lambda x: x % 2 == 0, my_list)))
    print(my_list_1)

    my_list_2 = stream(my_list).filter(lambda x: x % 2 == 0).map(lambda x: x ** 2).collect()
    print(my_list_2)

    # dict
    print()
    my_dict = {1: 1, 2: 2, 3: 3, "4": "4", "5": "5", "6": "6"}
    print(my_dict)

    def my_map(item):
        item["value"] = int(item["value"]) * int(item["value"])
        return item
    my_dict_2_1 = stream(my_dict).filter(lambda i: int(i["value"]) % 2 == 0).map(my_map).collect()
    print(my_dict_2_1)
    my_dict_2_2 = stream(my_dict).filter(lambda i: int(i["value"]) % 2 == 0).map(my_map).collect(False)
    print(my_dict_2_2)

 





使用示例：递归获取指定目录下，指定后缀的文件路径

# 递归获取 指定目录下指定后缀的文件，的路径
def getDeepFilePaths(filePaths, baseFilePath, ext="txt"):
    # 获取当前目录下的所有文件名
    f_list = os.listdir(baseFilePath)
    # 将当前目录下后缀名为指定后缀的文件，放入filePaths列表
    if ext:
        selectExt = f'.{ext}'
    else:
        selectExt = ""
    stream(f_list) \
        .filter(lambda fileName: os.path.splitext(fileName)[1] == selectExt) \
        .filter(lambda fileName: not os.path.isdir(f"{baseFilePath}/{fileName}")) \
        .forEach(lambda fileName: filePaths.append(baseFilePath + "/" + fileName))
    # 递归当前目录下的目录
    stream(f_list) \
        .map(lambda fileName: f"{baseFilePath}/{fileName}") \
        .filter(lambda f: os.path.isdir(f)) \
        .forEach(lambda dir: getDeepFilePaths(filePaths, dir, ext))


baseFilePath = "."
filePaths = []
getDeepFilePaths(filePaths,baseFilePath,"py")
stream(filePaths).print()

